// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: pkg/api/fleet/v1alpha1/fleet.proto

package v1alpha1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Cluster_MemberAdd_FullMethodName    = "/shikanime.elkia.fleet.v1alpha1.Cluster/MemberAdd"
	Cluster_MemberRemove_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.Cluster/MemberRemove"
	Cluster_MemberUpdate_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.Cluster/MemberUpdate"
	Cluster_MemberList_FullMethodName   = "/shikanime.elkia.fleet.v1alpha1.Cluster/MemberList"
)

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterClient interface {
	// MemberAdd adds a member into the cluster.
	MemberAdd(ctx context.Context, in *MemberAddRequest, opts ...grpc.CallOption) (*MemberAddResponse, error)
	// MemberRemove removes an existing member from the cluster.
	MemberRemove(ctx context.Context, in *MemberRemoveRequest, opts ...grpc.CallOption) (*MemberRemoveResponse, error)
	// MemberUpdate updates the member configuration.
	MemberUpdate(ctx context.Context, in *MemberUpdateRequest, opts ...grpc.CallOption) (*MemberUpdateResponse, error)
	// MemberList lists all the members in the cluster.
	MemberList(ctx context.Context, in *MemberListRequest, opts ...grpc.CallOption) (*MemberListResponse, error)
}

type clusterClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterClient(cc grpc.ClientConnInterface) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) MemberAdd(ctx context.Context, in *MemberAddRequest, opts ...grpc.CallOption) (*MemberAddResponse, error) {
	out := new(MemberAddResponse)
	err := c.cc.Invoke(ctx, Cluster_MemberAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) MemberRemove(ctx context.Context, in *MemberRemoveRequest, opts ...grpc.CallOption) (*MemberRemoveResponse, error) {
	out := new(MemberRemoveResponse)
	err := c.cc.Invoke(ctx, Cluster_MemberRemove_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) MemberUpdate(ctx context.Context, in *MemberUpdateRequest, opts ...grpc.CallOption) (*MemberUpdateResponse, error) {
	out := new(MemberUpdateResponse)
	err := c.cc.Invoke(ctx, Cluster_MemberUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) MemberList(ctx context.Context, in *MemberListRequest, opts ...grpc.CallOption) (*MemberListResponse, error) {
	out := new(MemberListResponse)
	err := c.cc.Invoke(ctx, Cluster_MemberList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServer is the server API for Cluster service.
// All implementations must embed UnimplementedClusterServer
// for forward compatibility
type ClusterServer interface {
	// MemberAdd adds a member into the cluster.
	MemberAdd(context.Context, *MemberAddRequest) (*MemberAddResponse, error)
	// MemberRemove removes an existing member from the cluster.
	MemberRemove(context.Context, *MemberRemoveRequest) (*MemberRemoveResponse, error)
	// MemberUpdate updates the member configuration.
	MemberUpdate(context.Context, *MemberUpdateRequest) (*MemberUpdateResponse, error)
	// MemberList lists all the members in the cluster.
	MemberList(context.Context, *MemberListRequest) (*MemberListResponse, error)
	mustEmbedUnimplementedClusterServer()
}

// UnimplementedClusterServer must be embedded to have forward compatible implementations.
type UnimplementedClusterServer struct {
}

func (UnimplementedClusterServer) MemberAdd(context.Context, *MemberAddRequest) (*MemberAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberAdd not implemented")
}
func (UnimplementedClusterServer) MemberRemove(context.Context, *MemberRemoveRequest) (*MemberRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberRemove not implemented")
}
func (UnimplementedClusterServer) MemberUpdate(context.Context, *MemberUpdateRequest) (*MemberUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberUpdate not implemented")
}
func (UnimplementedClusterServer) MemberList(context.Context, *MemberListRequest) (*MemberListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemberList not implemented")
}
func (UnimplementedClusterServer) mustEmbedUnimplementedClusterServer() {}

// UnsafeClusterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServer will
// result in compilation errors.
type UnsafeClusterServer interface {
	mustEmbedUnimplementedClusterServer()
}

func RegisterClusterServer(s grpc.ServiceRegistrar, srv ClusterServer) {
	s.RegisterService(&Cluster_ServiceDesc, srv)
}

func _Cluster_MemberAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).MemberAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_MemberAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).MemberAdd(ctx, req.(*MemberAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_MemberRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).MemberRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_MemberRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).MemberRemove(ctx, req.(*MemberRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_MemberUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).MemberUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_MemberUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).MemberUpdate(ctx, req.(*MemberUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_MemberList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemberListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).MemberList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_MemberList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).MemberList(ctx, req.(*MemberListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Cluster_ServiceDesc is the grpc.ServiceDesc for Cluster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cluster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shikanime.elkia.fleet.v1alpha1.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MemberAdd",
			Handler:    _Cluster_MemberAdd_Handler,
		},
		{
			MethodName: "MemberRemove",
			Handler:    _Cluster_MemberRemove_Handler,
		},
		{
			MethodName: "MemberUpdate",
			Handler:    _Cluster_MemberUpdate_Handler,
		},
		{
			MethodName: "MemberList",
			Handler:    _Cluster_MemberList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/fleet/v1alpha1/fleet.proto",
}

const (
	Presence_CreateLoginFlow_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.Presence/CreateLoginFlow"
	Presence_SubmitLoginFlow_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.Presence/SubmitLoginFlow"
	Presence_ClaimLoginFlow_FullMethodName  = "/shikanime.elkia.fleet.v1alpha1.Presence/ClaimLoginFlow"
)

// PresenceClient is the client API for Presence service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PresenceClient interface {
	// CreateLoginFlow creates a handoff flow with a given identifier and
	// password.
	CreateLoginFlow(ctx context.Context, in *CreateLoginFlowRequest, opts ...grpc.CallOption) (*CreateLoginFlowResponse, error)
	// SubmitLoginFlow hands off a session to a gateway with a given token and
	// code.
	SubmitLoginFlow(ctx context.Context, in *SubmitLoginFlowRequest, opts ...grpc.CallOption) (*SubmitLoginFlowResponse, error)
	// ClaimLoginFlow authenticates a gateway with a given identifier, password,
	// and token.
	ClaimLoginFlow(ctx context.Context, in *ClaimLoginFlowRequest, opts ...grpc.CallOption) (*ClaimLoginFlowResponse, error)
}

type presenceClient struct {
	cc grpc.ClientConnInterface
}

func NewPresenceClient(cc grpc.ClientConnInterface) PresenceClient {
	return &presenceClient{cc}
}

func (c *presenceClient) CreateLoginFlow(ctx context.Context, in *CreateLoginFlowRequest, opts ...grpc.CallOption) (*CreateLoginFlowResponse, error) {
	out := new(CreateLoginFlowResponse)
	err := c.cc.Invoke(ctx, Presence_CreateLoginFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *presenceClient) SubmitLoginFlow(ctx context.Context, in *SubmitLoginFlowRequest, opts ...grpc.CallOption) (*SubmitLoginFlowResponse, error) {
	out := new(SubmitLoginFlowResponse)
	err := c.cc.Invoke(ctx, Presence_SubmitLoginFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *presenceClient) ClaimLoginFlow(ctx context.Context, in *ClaimLoginFlowRequest, opts ...grpc.CallOption) (*ClaimLoginFlowResponse, error) {
	out := new(ClaimLoginFlowResponse)
	err := c.cc.Invoke(ctx, Presence_ClaimLoginFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PresenceServer is the server API for Presence service.
// All implementations must embed UnimplementedPresenceServer
// for forward compatibility
type PresenceServer interface {
	// CreateLoginFlow creates a handoff flow with a given identifier and
	// password.
	CreateLoginFlow(context.Context, *CreateLoginFlowRequest) (*CreateLoginFlowResponse, error)
	// SubmitLoginFlow hands off a session to a gateway with a given token and
	// code.
	SubmitLoginFlow(context.Context, *SubmitLoginFlowRequest) (*SubmitLoginFlowResponse, error)
	// ClaimLoginFlow authenticates a gateway with a given identifier, password,
	// and token.
	ClaimLoginFlow(context.Context, *ClaimLoginFlowRequest) (*ClaimLoginFlowResponse, error)
	mustEmbedUnimplementedPresenceServer()
}

// UnimplementedPresenceServer must be embedded to have forward compatible implementations.
type UnimplementedPresenceServer struct {
}

func (UnimplementedPresenceServer) CreateLoginFlow(context.Context, *CreateLoginFlowRequest) (*CreateLoginFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLoginFlow not implemented")
}
func (UnimplementedPresenceServer) SubmitLoginFlow(context.Context, *SubmitLoginFlowRequest) (*SubmitLoginFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitLoginFlow not implemented")
}
func (UnimplementedPresenceServer) ClaimLoginFlow(context.Context, *ClaimLoginFlowRequest) (*ClaimLoginFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimLoginFlow not implemented")
}
func (UnimplementedPresenceServer) mustEmbedUnimplementedPresenceServer() {}

// UnsafePresenceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PresenceServer will
// result in compilation errors.
type UnsafePresenceServer interface {
	mustEmbedUnimplementedPresenceServer()
}

func RegisterPresenceServer(s grpc.ServiceRegistrar, srv PresenceServer) {
	s.RegisterService(&Presence_ServiceDesc, srv)
}

func _Presence_CreateLoginFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLoginFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PresenceServer).CreateLoginFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Presence_CreateLoginFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PresenceServer).CreateLoginFlow(ctx, req.(*CreateLoginFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Presence_SubmitLoginFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitLoginFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PresenceServer).SubmitLoginFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Presence_SubmitLoginFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PresenceServer).SubmitLoginFlow(ctx, req.(*SubmitLoginFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Presence_ClaimLoginFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimLoginFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PresenceServer).ClaimLoginFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Presence_ClaimLoginFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PresenceServer).ClaimLoginFlow(ctx, req.(*ClaimLoginFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Presence_ServiceDesc is the grpc.ServiceDesc for Presence service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Presence_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shikanime.elkia.fleet.v1alpha1.Presence",
	HandlerType: (*PresenceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLoginFlow",
			Handler:    _Presence_CreateLoginFlow_Handler,
		},
		{
			MethodName: "SubmitLoginFlow",
			Handler:    _Presence_SubmitLoginFlow_Handler,
		},
		{
			MethodName: "ClaimLoginFlow",
			Handler:    _Presence_ClaimLoginFlow_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/fleet/v1alpha1/fleet.proto",
}

const (
	IdentityManager_Login_FullMethodName        = "/shikanime.elkia.fleet.v1alpha1.IdentityManager/Login"
	IdentityManager_RefreshLogin_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.IdentityManager/RefreshLogin"
	IdentityManager_WhoAmI_FullMethodName       = "/shikanime.elkia.fleet.v1alpha1.IdentityManager/WhoAmI"
	IdentityManager_Logout_FullMethodName       = "/shikanime.elkia.fleet.v1alpha1.IdentityManager/Logout"
)

// IdentityManagerClient is the client API for IdentityManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IdentityManagerClient interface {
	// Login hands off a session to a gateway with a given token and
	// code.
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// RefreshLogin authenticates a gateway with a given identifier, password, and
	// token.
	RefreshLogin(ctx context.Context, in *RefreshLoginRequest, opts ...grpc.CallOption) (*RefreshLoginResponse, error)
	// WhoAmI returns the session associated with a given token.
	WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error)
	// Logout logs out a session with a given code.
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
}

type identityManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewIdentityManagerClient(cc grpc.ClientConnInterface) IdentityManagerClient {
	return &identityManagerClient{cc}
}

func (c *identityManagerClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, IdentityManager_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityManagerClient) RefreshLogin(ctx context.Context, in *RefreshLoginRequest, opts ...grpc.CallOption) (*RefreshLoginResponse, error) {
	out := new(RefreshLoginResponse)
	err := c.cc.Invoke(ctx, IdentityManager_RefreshLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityManagerClient) WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error) {
	out := new(WhoAmIResponse)
	err := c.cc.Invoke(ctx, IdentityManager_WhoAmI_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityManagerClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, IdentityManager_Logout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IdentityManagerServer is the server API for IdentityManager service.
// All implementations must embed UnimplementedIdentityManagerServer
// for forward compatibility
type IdentityManagerServer interface {
	// Login hands off a session to a gateway with a given token and
	// code.
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// RefreshLogin authenticates a gateway with a given identifier, password, and
	// token.
	RefreshLogin(context.Context, *RefreshLoginRequest) (*RefreshLoginResponse, error)
	// WhoAmI returns the session associated with a given token.
	WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error)
	// Logout logs out a session with a given code.
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	mustEmbedUnimplementedIdentityManagerServer()
}

// UnimplementedIdentityManagerServer must be embedded to have forward compatible implementations.
type UnimplementedIdentityManagerServer struct {
}

func (UnimplementedIdentityManagerServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedIdentityManagerServer) RefreshLogin(context.Context, *RefreshLoginRequest) (*RefreshLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshLogin not implemented")
}
func (UnimplementedIdentityManagerServer) WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhoAmI not implemented")
}
func (UnimplementedIdentityManagerServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedIdentityManagerServer) mustEmbedUnimplementedIdentityManagerServer() {}

// UnsafeIdentityManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IdentityManagerServer will
// result in compilation errors.
type UnsafeIdentityManagerServer interface {
	mustEmbedUnimplementedIdentityManagerServer()
}

func RegisterIdentityManagerServer(s grpc.ServiceRegistrar, srv IdentityManagerServer) {
	s.RegisterService(&IdentityManager_ServiceDesc, srv)
}

func _IdentityManager_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityManagerServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityManager_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityManagerServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityManager_RefreshLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityManagerServer).RefreshLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityManager_RefreshLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityManagerServer).RefreshLogin(ctx, req.(*RefreshLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityManager_WhoAmI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhoAmIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityManagerServer).WhoAmI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityManager_WhoAmI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityManagerServer).WhoAmI(ctx, req.(*WhoAmIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityManager_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityManagerServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityManager_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityManagerServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IdentityManager_ServiceDesc is the grpc.ServiceDesc for IdentityManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IdentityManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shikanime.elkia.fleet.v1alpha1.IdentityManager",
	HandlerType: (*IdentityManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _IdentityManager_Login_Handler,
		},
		{
			MethodName: "RefreshLogin",
			Handler:    _IdentityManager_RefreshLogin_Handler,
		},
		{
			MethodName: "WhoAmI",
			Handler:    _IdentityManager_WhoAmI_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _IdentityManager_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/fleet/v1alpha1/fleet.proto",
}

const (
	SessionManager_GetSession_FullMethodName    = "/shikanime.elkia.fleet.v1alpha1.SessionManager/GetSession"
	SessionManager_PutSession_FullMethodName    = "/shikanime.elkia.fleet.v1alpha1.SessionManager/PutSession"
	SessionManager_DeleteSession_FullMethodName = "/shikanime.elkia.fleet.v1alpha1.SessionManager/DeleteSession"
)

// SessionManagerClient is the client API for SessionManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionManagerClient interface {
	// GetSession gets a session with a given code.
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error)
	// PutSession creates a session with a given identifier and token.
	PutSession(ctx context.Context, in *PutSessionRequest, opts ...grpc.CallOption) (*PutSessionResponse, error)
	// DeleteSession Deletes a session with a given code.
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error)
}

type sessionManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionManagerClient(cc grpc.ClientConnInterface) SessionManagerClient {
	return &sessionManagerClient{cc}
}

func (c *sessionManagerClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error) {
	out := new(GetSessionResponse)
	err := c.cc.Invoke(ctx, SessionManager_GetSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) PutSession(ctx context.Context, in *PutSessionRequest, opts ...grpc.CallOption) (*PutSessionResponse, error) {
	out := new(PutSessionResponse)
	err := c.cc.Invoke(ctx, SessionManager_PutSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error) {
	out := new(DeleteSessionResponse)
	err := c.cc.Invoke(ctx, SessionManager_DeleteSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionManagerServer is the server API for SessionManager service.
// All implementations must embed UnimplementedSessionManagerServer
// for forward compatibility
type SessionManagerServer interface {
	// GetSession gets a session with a given code.
	GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error)
	// PutSession creates a session with a given identifier and token.
	PutSession(context.Context, *PutSessionRequest) (*PutSessionResponse, error)
	// DeleteSession Deletes a session with a given code.
	DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error)
	mustEmbedUnimplementedSessionManagerServer()
}

// UnimplementedSessionManagerServer must be embedded to have forward compatible implementations.
type UnimplementedSessionManagerServer struct {
}

func (UnimplementedSessionManagerServer) GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedSessionManagerServer) PutSession(context.Context, *PutSessionRequest) (*PutSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSession not implemented")
}
func (UnimplementedSessionManagerServer) DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedSessionManagerServer) mustEmbedUnimplementedSessionManagerServer() {}

// UnsafeSessionManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionManagerServer will
// result in compilation errors.
type UnsafeSessionManagerServer interface {
	mustEmbedUnimplementedSessionManagerServer()
}

func RegisterSessionManagerServer(s grpc.ServiceRegistrar, srv SessionManagerServer) {
	s.RegisterService(&SessionManager_ServiceDesc, srv)
}

func _SessionManager_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_PutSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).PutSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_PutSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).PutSession(ctx, req.(*PutSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionManager_ServiceDesc is the grpc.ServiceDesc for SessionManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shikanime.elkia.fleet.v1alpha1.SessionManager",
	HandlerType: (*SessionManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSession",
			Handler:    _SessionManager_GetSession_Handler,
		},
		{
			MethodName: "PutSession",
			Handler:    _SessionManager_PutSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _SessionManager_DeleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/fleet/v1alpha1/fleet.proto",
}
